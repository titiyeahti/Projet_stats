---
title: "Projet - MST"
author: "Thibaut MILHAUD & Thomas KOWALSKI"
date: "6 mai 2018"
output:
  html_document:
    df_print: paged
---

## Statistiques descriptives

### Comparaison hommes/femmes

```{r sexism}

data <- read.csv(file = "DB_binome_2.csv");
n <- nrow(data);
mandata <- c();
womandata <- c();
for (i in 1:n)
{
  if(data[i, 'Sexe'] == 0)
  {
    mandata <- c(mandata, data[i, 'Peche'])
  }
  else
  {
    womandata <- c(womandata, data[i, 'Peche'])
  }
}
print(mean(womandata))
print(mean(mandata))
boxplot(mandata, womandata)

```

### Distribution de la pêche en fonction de la tranche d'âge

```{r}
tranches = c(0, 0, 0)
for (i in seq(1, n)) {
    tranche = data[i, "Age"]
    tranches[tranche - 1] = tranches[tranche - 1] + data[i, "Peche"]
}
barplot(tranches)
```

### Intensité du vent

```{r}
hist(data[,'Noeuds'])
```
On dirait une loi de poisson.


### Quantité de pêche

```{r}
hist(data[,'Peche'])
```
On dirait une loi Normale.

## Statistiques Inférentielles

### Le vent

```{r}
#On regarde la cohérence par rapport à la loi de poisson
a <- seq(0,8,1)
lambda = mean(data[,'Noeuds'])

hist(data[,'Noeuds'],freq=FALSE,breaks = seq(0,8,1))
par(new=TRUE)
plot(a,dpois(a,lambda),"l",col="red")



```

#### Vraisemblance

Soit $X$ un echantillon de taille $n$ suivant une loi de poisson de paramêtre $\lambda$, alors sa vraisemblance vaut :
\[
L_\lambda(X) = \prod_{i = 1}^n \exp(-\lambda)\frac{\lambda^{x_i}}{x_i!} = \exp(-n\lambda)\frac{\lambda^{\sum x_i}}{\prod x_i!}
\]
d'où, 
\[
\mathcal L_\lambda(X) = \log(L_\lambda(X)) = -n\lambda + \log \lambda \sum x_i - \sum \log x_i!
\]
Ainsi en dérivant $\mathcal L_\lambda(X)$ par rapport à $\lambda$, on obtient :
\[
{\partial \mathcal L_\lambda(X) \over \partial \lambda } = -n + \frac{\sum x_i}{\lambda}
\]
et 
\[
{\partial^2 \mathcal L_\lambda(X) \over \partial \lambda^2} = -\frac{\sum x_i}{\lambda^2} \leq 0
\]
La log-vraisemblance est donc concave ce qui signifie que les points où la dérivée s'annule sont des maximums globaux. Ainsi,
\[
\lambda_\max = {\sum^n_{i=1} x_i \over n}
\]

```{r}
log_L = function(x, l) {
  s = 0
  for(i in seq(1, length(x)))
  {
    s = s + log(factorial(x[i]))
  }
  return(-1 * length(x) * l + log(l) * sum(x) - s)
}

x = seq(0, 10, 0.1)
plot(x = x, 
     y = log_L(data[, "Noeuds"], x),
     main = "Vraisemblance en fonction de lambda",
     xlab = "lambda",
     ylab = "L_lambda(X)",
     type = "l")
```

#### Lambda

Par en appliquant la formule trouvée ci-dessu, on obtient :
```{r}
lambda = mean(data[,'Noeuds'])
print(lambda)
par(new = FALSE)
plot(x, x * lambda / x, type = "l")
```

### Vraisemblance de la loi normale

Soit $X$ un echantillon de taille $n$ suivant une loi normale d'écart-type $\sigma$ et d'espérance $\mu$ : $X\sim\mathcal{N}(\mu, \sigma^2)$, alors sa vraisemblance vaut :
\[
L_\sigma(X) = \prod_{i = 1}^n \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x_i-\mu)^2}{2\sigma^2}} \\
            = \left( \frac{1}{\sqrt{2\pi}\sigma} \right) ^n \exp\left({-\sum_{i=1}^n \frac{(x_i-\mu)^2}{2\sigma^2}}\right)
\]

d'où pour tout :

\[
  P(pêche = x) = \sum_{i = 0}^\infty P(vent = i) \times \mathbb{P}(peche = x | vent = i)
\]

Donc
  
\[
  L_\sigma(x) = \sum_{i = 0}^\infty e^{-i} \frac{\lambda^i}{i!} \left( \frac{1}{\sqrt{2\pi}\sigma} \right) ^n \exp\left({-\sum_{i=1}^n \frac{(x_i-\frac{100}{1 + i})^2}{2\sigma^2}}\right)
\]

Pour nos applications numériques, on veut trouver $i$ tel que $\mathbb{P}(vent = i) < 0.00001$ (sachant qu'on utilise le $\lambda$ de max vraisemblance trouvé précédemment.)

```{r}
print(lambda)
for(i in seq(1, 100)) {
  p = exp(-1 * lambda) * lambda ^ i / factorial(i)
  if (p < 0.00001)
  {
    break
  }
}
print(i)
```

On trouve donc que la valeur de vent dont la probabilité est inférieure à 0.0000001 est **11**.

Pour déterminer le $\sigma$ de maximum vraisemblance on utilise la fonction `optimize` avec une fonction de vraisemblance que l'on définit. 

```{r}
l = function(sigma, lambda, x, imax) {
  somme = 0
  for (i in seq(0, imax)) {
    somme = somme + exp(-i) * lambda^i / factorial(i) * (1 / (sqrt(2 * pi) * sigma)) ^ length(x)
    sousSomme = 0
    for (k in seq(1, length(x))) {
      sousSomme = sousSomme + (x[i] - 100 / (1 + i)) ^ 2 / (2 * sigma ^ 2)
    }
    somme = somme * exp(-1 * sousSomme)
  }
  return(somme)
}
```

```{r}
vec = data[, "Peche"]
imax = 11
f = function(x) l(x, lambda, vec, imax)
sig = optimize(f = f, maximum = TRUE, lower = 0, upper = 10)
print(sig)
```

### Maximum de vraisemblance pour $\sigma$ (en utilisant la formule théorique)

En appliquant cette formule, on trouve

```{r}
sigmas = c()
for (lambda in seq(0, 8)) {
  mu = 100 / (1 + lambda)
  
  x = c()
  for (i in seq(1, n)) {
    if (data[i, "Noeuds"] == lambda)
    {
      x = c(x, data[i, "Peche"])
    }
  }
  
  s = 0
  for (i in seq(1, length(x))) {
    s = s + (x[i] - mu) * (x[i] - mu)
  }
  sigma = 1 / length(x) 
  sigmas = c(sigmas, sigma)
}
print(sigmas)
```

**Interprétation :** plus le vent est fort, plus le volume de pêche varie.

**Remarque :** les valeurs pour $\lambda$ *grand* sont peu valables puisque l'échantillon est petit.

### Deuxième méthode : TCL

### Tracé de la log vraisemblance

## Intervalles de confiance

### Intervalle de confiance asymptotique pour $\lambda$

### Ultime question

On veut vérifier que lorsque $\lambda = 3$, la QUANTITE DE PECHE suit une loi $\mathcal{N}(\frac{100}{1 + \lambda}, \sigma^2)$ avec $\sigma = 20$. On veut savoir pour quel $\alpha$ on ne peut rejeter cette hypothèse.

On utilise le test $\chi^2$. 

```{r}
peche = c()
for (i in seq(1, n)) {
  if (data[i, "Noeuds"] == 3)
  {
    peche = c(peche, data[i, "Peche"])
  }
}


k = 15
m = min(peche)
M = max(peche)

intervalles = seq(m, M, length.out = k)
print(intervalles)

muChapeau = 0
for(i in seq(1, k - 1))
{
  ci = (intervalles[i] + intervalles[i + 1])
  ni = 0
  for (j in seq(1, length(peche)))
  {
    if (peche[j] >= intervalles[i])
    {
      if(peche[j] < intervalles[i + 1])
      {
        ni = ni + 1
      }
    }
  }
  muChapeau = muChapeau + ci * ni
}
muChapeau = muChapeau / length(peche)

sigmaChapeau = 0
for(i in seq(1, k - 1))
{
  ci = (intervalles[i] + intervalles[i + 1])
  ni = 0
  for (j in seq(1, length(peche)))
  {
    if (peche[j] >= intervalles[i])
    {
      if(peche[j] < intervalles[i + 1])
      {
        ni = ni + 1
      }
    }
  }
  sigmaChapeau = sigmaChapeau + ni * (ci - muChapeau) * (ci - muChapeau)
}
sigmaChapeau = sigmaChapeau / length(peche)
sigmaChapeau = sqrt(sigmaChapeau)

print(muChapeau)
print(sigmaChapeau)

```